# Размер имеет значение

В детстве мы играли в простую, но удивительно поучительную игру. Дети становились в круг, и один из них начинал перекидывать мяч. Но это был не просто мяч — это была «горячая картошка». И правила были предельно ясны: поймал — тут же бросай дальше. Максимум одна секунда. Кто задержал — проиграл. Никаких пауз, планов и стратегий. Только действие. Только передача.

Если ты хоть на мгновение задумался — обжёгся. 
Ты должен доверять интуиции, не копаться в себе и не мешать движению игры.

Так и с кодом. Каждый класс, каждый метод, каждая строка — это не долгий монолог, а быстрый пас, моментальный результат, передача задачи следующему игроку. Код не должен «держать мяч» в руках подолгу, копаться в себе, раздувать внутренние сложности, мешать движению.

У каждого должна быть одна цель — передать задачу и не тормозить процесс. 
Ассоциируйте это как:

- Класс — это игрок.
- Метод — это пас. Он может быть левой рукой, правой, можно схватить или отбросить мяч.
- Строки — это момент перед броском.


Когда момент перед пасом выглядит вот так:

```php
// Слишком длинный метод ❌
public function handle() 
{
    // ...
    // ...
    // 1000 строк кода

    return $result;
}
```

То получается, что игрок ловит мяч и... 
Он ловит мяч и… не бросает. Он встал посреди круга и начал делать кувырки, включил музыку, рассказал стихотворение и только потом — спустя долгие секунды — наконец передал мяч дальше.

Это раздражает не только других игроков при игре, ведь тоже самое происходит с кодом, когда его размер выходит за разумные пределы. Длинные методы и классы начинают
запутывать, а вместо ясности мы получаем неразбериху, с которой сложно работать. 

Точно так же, как перегруженные предложения, огромные блоки кода перегружают восприятие. Читая их, трудно понять, о чём конкретно идёт речь, и приходится возвращаться к началу, чтобы разобраться, что вообще происходит.

Худшие разработчики будут гордиться таким кодом и говорить, да он сложный, да он умный, да он крутой. Но на самом деле это просто неумение передать мяч как можно быстрее. Ленивые или некомпетентные программисты будут разбивать ее на логические шаги, например:

```php
// Слишком длинный метод ❌
public function handle() 
{
    // Загрузка данных
    // Валидация
    // Преобразование
    // Генерация отчёта
    // Сохранение в файл
    // Отправка по почте
    // И ещё десяток шагов...
    $this->step();
    $this->step();
    $this->step();
    
    $this->load();
    $this->validate();
    $this->transform();
    $this->generateReport();
    // И ещё десяток шагов...
    $this->sendMail();

    return $result;
}
```

На первый взгляд — красиво, ведь метод `export()` в пять строчек. Но где тут само «сердце»? Вам приходится прыгать из метода в метод, искать смысл: «а, здесь что-то подгружается, а вот здесь валидируется, а вот здесь ещё что-то происходит…». Получается эффект «многостёковой передачной паутины»: глаз бегает по коду без чувства завершённости.

Правильно дробить — значит давать каждому методу собственную осмысленную ответственность, а не делать «пустую оболочку» ради экономии строк. Если метод публичный, он должен отражать высокоуровневый шаг, понятный «с первого взгляда». А приватные методы должны решать действительно отдельный логический блок, а не просто «задёргивать» следующий вызов без собственной логики.

Хороший публичный метод должен вызывать у вас реакцию: «Да, это целостный шаг!» Например:

```php
// Хорошо ✅
public function handle()
{
    $exporter = new ModelExport($this);

    $content = $exporter->toString();
 
    return $user->notify(ExportNotification::class, [
        'content' => $content,
    ]);
}
```

Теперь мы наглядно видим, что сделали пас.

Игра «горячая картошка» научила нас — не задерживать ответственность. 
Теперь разберём конкретные техники, которые позволяют быстрее передать «мяч» дальше.
