# Именование

После беглого просмотра кода, первое, что мы действительно читаем после установки и запуска это имена переменных,
методов и классов.

```php
// Плохо ❌
$data;
$var;
$info;
```

На первый взгляд такие переменные выглядят нормально.
Но что именно в них хранится? Это может быть пользователь, список заказов или какой-нибудь внутренний флаг.
Мы не знаем, пока не залезем вглубь, что присваивается, отслеживать, как используется и даже когда мы узнаем, что такое `$data`, то в другом участке кода это может означать соверешнно другое.


Это относится и к методам, иногда вполне нормально иметь метод `run` для классов которые выполняют одну единственную функцию. Но это совершенно не информативно для масштабных объектов, например:

```php
// Плохо ❌
$user->run();
$user->handleData();
$user->process()
```

Старайтесь использовать информативные имена, которые отражают суть того, что они представляют, например:

```php
// Хорошо ✅
$user->posts();
$user->notify(...);
$user->deactivate();
```


Использование сокращений может показаться удобным для быстрого написания кода. 
Это может быть как однобуквенные вариации `$i` или `q` так и сокращения. 
Но они только приводят привести к путанице и усложнить поддержку кода. 
Код наполненными сокращениями похож на шифровку. А мы же не в разведке.

Давайте рассмотрим следующий пример:

```php
// Плохо ❌
$usr = User::find($id);

// Хорошо ✅
$currentUser = User::find($userId);
```

Здесь переменная `$usr` представляет объект пользователя. Однако, сокращённое имя `$usr` не даёт понимания того, что именно хранится в этой переменной. Более ясное имя, например, `$currentUser`, немедленно указывает на её предназначение.

```php
// Плохо ❌
class UsrCtrl extends Controller {
    public function f() {
        // ...
    }
}
```

В данном примере имя класса `UsrCtrl` не информативно. Разработчику, сталкивающемуся с этим классом впервые, будет трудно понять его назначение. Название класса должно чётко отражать его функциональность, например, `ProfileController`.

```php
// Хорошо ✅
class ProfileController extends Controller
{
    public function show()
    {
        // ...
    }
}
```


Методы и переменные которые содержат `bool` значение, лучше всего именовать с префиксом `is/has/should`

```php
// Хорошо ✅
$isAdmin
$hasAccess
$shouldRetry
```


Теперь давайте рассмотрим пример именования с единицами измерений

```php
// Плохо ❌
// Мы не знаем, что представляет собой число 100
$averageTime = 100;

// Хорошо ✅
// Мы понимаем что значение имеет величину 100мс
$averageTimeInMs = 100;
```

Другой способ справиться с этим — создать специальные объекты. Представьте, что вам нужно работать с процентами. Что из этого верно?

```php
// Плохо ❌
$percentage = 0.5;
$percentage = 50;
```

Встретив такую переменную, вы не сможете сказать какое значение ожидает ваше приложение.
Давайте теперь воспользуемся объектом со статическим конструктором, по одному для каждой возможности.

```php
class Percentage
{
    public static function fromInt(int $percentage): self
    {
        return new self($percentage);
    }

    public static function fromFloat(float $percentage): self
    {
        return new self($percentage * 100);
    }

    private function __construct(
        public int $value;
    ) {};
}
```

Использование класса `Percentage` поясняет, что ожидается целое число.

```php
// Хорошо ✅
$percentage = Percentage::fromFloat(0.5);
$percentage = Percentage::fromInt(50);
```



> **Примечание** Помните, что названия должны использовать объясняющие слова, которые помогают понять их назначение.
> Не стесняйтесь использовать длинные имена, если они ясно описывают сущность. Или `html`

### Будьте кратки

Но не стоит пытаться расписать все длинными именами в надежде, что они ....
Давайте ровно столько информации, чтобы можно было уверенно принимать решения. Уберите все лишние слова.

Наш коллега написал, примерно такой класс, для игнорирования сущностей обширно описывая каждый метод и свойство:

```php
// Плохо ❌
class ExcludeItemStorage
{
    private ?array $excludeStorage = [];

    public function addItem(string $itemName, string $itemIdentityName, string $itemIdentityValue)
    {
        // ...
    }

    public function isItemExcluded(string $itemName, string $itemIdentityName, string $itemIdentityValue): bool
    {
        // ...
    }

    public function unsetExcludeStorage(): void
    {
         $this->excludeStorage = null;
    }
}
```

Выглядит так как будто он прочитал несколько книжек и хочет сделать все очень понятным, но делает ровно наоборот.

Для чего нам в имени класса `Item`, как он нам помогает что либо понять? Куда сохраняются игнорируемые значения, storage это файловая система? 
У нас есть излишни описанный класс который нам не дает ни какой информации. Можно переименовать в `ExclusionList`.

А в место текущих методов предложить очень простую и дружелюбную альтернативу — краткий класс, у которого всего три понятных метода: `add`, `has` и `clear`. 
Они делают ровно то, что от них ожидаешь, и не заставляют никого слушать/читать лишние слова. 


### Использовании суффикса `-er`

В мире объектно-ориентированного программирования слишком часто встречаются имена классов вроде:

- Manager
- Controller
- Formatter
- Presenter

Эти имена плохи не потому, что они технически неверны. 
Они плохи потому, что не говорят ничего, конкретного, слшиком абстрактны.

```php
class ReportManager { /* … */ }
class StringFormatter { /* … */ }
```

TODO: Рассказать!



### Имена тоже должны рифмоваться 

> TODO: Часть симметрия

Вот пример:

```php
// Плохо ❌
$this->startProcess();
$this->completeTask();
```
Методы звучат как из разных историй.
Начали процесс — закончили задачу? Лучше, если имена соответствуют:

```php
// Хорошо ✅
$this->startProcess();
$this->finishProcess();
```

или

```php
$this->beginTask();
$this->completeTask();
```
Так логика читается как пара, как вызов и отклик. 


