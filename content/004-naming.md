# Именование

Когда мы читаем чужой код, первое, что мы читаем это имена. 

~~Хорошие имена помогают понять код и упрощают его поддержку и развитие.
Например, если вы встретите такие имена в большой области контекста, то не получите понимания о том, что происходит, а после перехода в другой участок кода вам снова придётся вникать в суть переменной или метода, что займёт много времени и сил:~~

```php
// Переменные ❌
$data;
$var;
$info;;
```

На первый взгляд такие переменные выглядят нормально.
Но что именно в них хранится? Это может быть пользователь, список заказов или какой-нибудь внутренний флаг.
Мы не знаем, пока не залезем вглубь, что присваивается, отслеживать, как используется и даже когда мы узнаем, что такое `$data`, то в другом участке кода это может означать соверешнно другое.


Это относится и к метода, иногда в полне нормально иметь метод `run` для классов которые выполняют одну еднственную функцию.
Но это совершенно не информативно для масштабных обьектов, например:

```php
// Методы ❌
$user->run();
$user->handleData();
$user->process()
```

Старайтесь использовать информативные имена, которые отражают суть того, что они представляют, например:

```php
// Хорошо ✅
$user->posts();
$user->notify(...);
$user->deactivate();
```

Использование сокращений может показаться удобным для быстрого написания кода, но они могут привести к путанице и усложнить поддержку кода.

Давайте рассмотрим следующий пример:

```php
// Плохо ❌
$usr = User::find($id);

// Хорошо ✅
$currentUser = User::find($userId);
```

Здесь переменная `$usr` представляет объект пользователя. Однако, сокращённое имя `$usr` не даёт понимания того, что именно хранится в этой переменной. Более ясное имя, например, `$currentUser`, немедленно указывает на её предназначение.

```php
// Плохо ❌
class UsrCtrl extends Controller {
    public function f1() {
        // ...
    }
}
```

В данном примере имя класса `UsrCtrl` не информативно. Разработчику, сталкивающемуся с этим классом впервые, будет трудно понять его назначение. Название класса должно чётко отражать его функциональность, например, `ProfileController`.

```php
// Хорошо ✅
class ProfileController extends Controller
{
    public function get()
    {
        // ...
    }
}
```

Теперь давайте рассмотрим пример именования с единицами измерений

```php
// Плохо ❌
// Мы не знаем, что представляет собой число 100
$averageTime = 100;

// Хорошо ✅
// Мы понимаем что значение имеет величину 100мс
$averageTimeInMs = 100;
```

Другой способ справиться с этим — создать специальные объекты. Представьте, что вам нужно работать с процентами. Что из этого верно?

```php
// Плохо ❌
$percentage = 0.5;
$percentage = 50;
```

Встретив такую переменную, вы не сможете сказать какое значение ожидает ваше приложение.
Давайте теперь воспользуемся объектом со статическим конструктором, по одному для каждой возможности.

```php
class Percentage
{
    public static function fromInt(int $percentage): self
    {
        return new self($percentage);
    }

    public static function fromFloat(float $percentage): self
    {
        return new self($percentage * 100);
    }

    private function __construct(
        public int $value;
    ) {};
}
```

Использование класса `Percentage` поясняет, что ожидается целое число.

```php
// Хорошо ✅
$percentage = Percentage::fromFloat(0.5);
$percentage = Percentage::fromInt(50);
```

> **Примечание** Помните, что названия должны использовать объясняющие слова, которые помогают понять их назначение. Не стесняйтесь использовать длинные имена, если они ясно описывают сущность. Или `html`



### Будьте кратки

Давайте ровно столько информации, чтобы можно было уверенно принимать решения. Уберите все лишние слова.

Наш коллега написал, примерно такой класс, для игнорирования сущностей:

```php
// Плохо ❌
class ExcludeItemStorage
{
    private ?array $excludeStorage = [];

    public function addItem(string $itemName, string $itemIdentityName, string $itemIdentityValue)
    {
        // ...
    }

    public function isItemExcluded(string $itemName, string $itemIdentityName, string $itemIdentityValue): bool
    {
        // ...
    }

    public function unsetExcludeStorage(): void
    {
         $this->excludeStorage = null;
    }
}
```

Выглядит так как будто он прочитал несколько книжек и хочет сделать все очень понятным, но делает ровно наоборот.

Для чего нам в имени класса `Item`, как он нам помогает что либо понять? 
