# Аргументы

### Чем меньше, тем лучше

Методы с большим числом аргументов сложнее читать, тестировать и использовать.
**Правило трёх**: метод не должен принимать больше **трёх параметров**. Если больше — разделите.

```php
// Плохо ❌
$fileSystem->write(
    '/path/to/file.txt',         // Путь до файла
    true,                        // Перезаписать файл, если он существует
    'Пример данных для записи.', // Содержимое
    'UTF-8',                     // Кодировка
    true                         // Включаем логирование
);
```

Если у метода четыре, пять, а то и шесть параметров — становится сложно понять, что есть что, в каком порядке это передавать, и как вообще это использовать. Особенно это усугубляется когда имена аргументов очень похожи.

Даже если вы напишете великолепный комментарий перед методом, человек читающий код будет вынужден каждый раз к нему возвращаться.

### Необязательные аргументы — в конец

```php
// Плохо ❌
$fileSystem->write(
    '/path/to/file.txt',         // Путь до файла
    null,                        // Перезаписать файл, если он существует
    'Пример данных для записи.', // Содержимое
);
```

```php
// Хорошо ✅
$fileSystem->write(
    '/path/to/file.txt',         // Путь до файла
    'Пример данных для записи.', // Содержимое
);
```

### Как поступить, если аргументов много?

Используйте именованные аргументы

```php
// Хорошо ✅
$fileSystem->write(
    '/path/to/file.txt',         // Путь до файла
    'Пример данных для записи.', // Содержимое
    debug: true,
);
```

Если параметры логически связаны, создайте объект, инкапсулирующий их. Например:

```php
$config = new Config($encoding, $overwrite, $debug);

// Пример использования
$fileSystem->write(
    '/path/to/file.txt',         // Путь до файла
    null,                        // Перезаписать файл, если он существует
    $config,                     //
);
```

Такой подход упрощает передачу параметров, делает код самодокументируемым и облегчает переиспользование.

Но есть и намного лучше вариант, использоваение fluent-интерфейс.
Это это объект, методы которого возвращают самого себя, позволяя вызывать методы цепочкой:

```php
// Хорошо ✅
$fileSystem
    ->path('/path/to/file.txt')
    ->encoding('UTF-8')
    ->overwrite(true)
    ->debug(true)
    ->write('Пример данных для записи.');
```



### Предпочитайте обьекты

Строки, булевые, числа очень удобны в начале разработки, но проект раснет, логика усложняется, и эти простые значения не справляются.

Что раньше было флагом `true`, теперь требует дополнительных условий:
*если админ*, *если включён режим отладки*, *если пользователь подтвердил e-mail*.

Скалярные значения не умеют расти. Они не подстраиваются под новые требования.
А объект — может. Он расширяется методами, валидирует себя, хранит контекст и смысл.

Возьмем ранее расмотренный пример из предыдущей главы про игнорируемый список, который мы уже немного улучшили:

```php
// Плохо ❌
class ExcludeList
{
    private array $$list = [];

    public function add(string $itemName, string $itemIdentityName, string $itemIdentityValue)
    {
        // ...
    }

    public function has(string $itemName, string $itemIdentityName, string $itemIdentityValue): bool
    {
        // ...
    }

    public function clear(): void
    {
         $this->list = [];
    }
}
```

Вместо того чтобы передавать несколько строковых значений, можно использовать уже существующий объект или создать новый, который сам решит, как обработать добавление и поиск элемента:

```php
// Хорошо ✅
class ExcludeList
{
    private array $$list = [];

    public function add(Model $model): static
    {
        $key = $model->getKey();
        // ...
    }

    public function has(Model $model): bool
    {
        $key = $model->getKey();
        // ...
    }

    public function clear(): static
    {
         $this->list = [];

         return $this;
    }
}
```

Теперь метод `add` и метод `has` работают с объектами, а не с простыми значениями. 
Это упрощает добавление новых параметров и изменений в модель, не затрагивая логику работы методов, а также облегчает тестирование.



TODO: Раздел `Предпочитайте обьекты` конфликтует с `Как поступить, если аргументов много?`
