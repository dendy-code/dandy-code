# Загадочные значения

Никто не начинает изучение проекта с вдумчивого чтения всей вики. 
Разработчик открывает IDE, запускает поиск по имени метода или класса, и — вперёд, прямо в код. 
Только когда поведение становится неочевидным, когда логика не складывается — он обращается к документации, вики, базе знаний если такая вообще есть или еще хуже к колеге выпрашивая информацию по чайной ложке.

Рассмотрим распространённую ситуацию:

```php
// Плохо ❌
if ($status == 1) {
    // ...
}
```

На первый взгляд — ничего страшного. Просто проверка статуса.
Но что значит это число `1`? Почему именно оно?

Разработчик, который это писал, наверняка знает, что `1` здесь означает "активный статус".
Но для всех остальных — это магическое число, появившееся из ниоткуда.
Код превращается в загадку: *почему не `0`? А может быть ли значение `2`? А в статус приходит `1` или `true`?*

Теперь представьте, что этот код читает кто-то вроде меня — из мира Linux.
В Unix-системах код `0` означает успешное завершение, а `1` — **ошибку**.
И я интуитивно читаю этот код иначе: *"О, тут проверяется, что была ошибка?"*
Мои привычки вступают в конфликт с чужими соглашениями — и я начинаю сомневаться в логике самого кода.

А если значение гораздо больше, например:

```php
// Плохо ❌
if ($status == 24) {
    // ...
}
```

Что это значит? День рождения начальника? Номер ошибки? Идентификатор тайного соглашения?

Загадочными могут быть не только числа. Иногда код притаит за собой с набор символов:

```php
// Плохо ❌
if ($char === '%!') {
    // ...
}
```

Что значит `%!`? Если значение несёт смысл, пусть оно громко заявляет о себе именем. Тогда станет ясно, зачем он здесь и как его использовать дальше с помощью константы:

```php
// Хорошо ✅
const STATUS_ACTIVE = 1;

if ($status === STATUS_ACTIVE) {
    // ...
}
```

Теперь код стал более понятным и поддерживаемым. 
При его чтении сразу становится понятно, что проверяется в условии.

Можно пойти дальше ещё дальше и использовать перечисления для явного определения различных значений:

```php
enum Status: string
    case ACTIVE = 'active';
    case INACTIVE = 'inactive';
    case ARCHIVED = 'archived';
}

$status = Status::ACTIVE;

if ($status === Status::ACTIVE) {
    // ...
}
```

```php
enum Status: int
    case ACTIVE = 1;
    case INACTIVE = 2;
    case ARCHIVED = 3;
}

$status = Status::ACTIVE;

if ($status === Status::ACTIVE) {
    // ...
}
```

Такой подход делает код более читаемым и позволяет явно указать доступные значения статуса и использовать как типизированное значение в методах, например:

```php
function canBePublished(Status $status): bool
{
    // ...
}
```

Используя именованные константы или перечисления, мы делаем код более понятным и поддерживаемым, ведь нам не нужно обращаться ни к документации, ни к коллеге, за прояснениями что важно для разработки масштабируемых приложений.
