## Прими фреймворк. Или не используй его вовсе.

Программисты часто упрямы. Мы гордимся тем, что умеем абстрагироваться, строить свои слои и границы, моделировать сложные бизнес-процессы. Мы читаем книги, впитываем принципы SOLID, обсуждаем DDD на митапах и конференциях. Мы хотим, чтобы наш код жил дольше, чем фреймворк, на котором он написан.

Это выглядит как зрелость, но в действительности это просто страх зависимости. Мы боимся, что инструмент сделает нас менее универсальными. Что мы «завязнем» в платформе. Что не сможем мигрировать. Что нас будут называть «разработчик на XXX», а не просто «разработчик».

Но это — иллюзия.

> Брюс Ли говорил: не бойся того, кто знает тысячу приёмов. Бойся того, кто отточил один приём тысячу раз.

## Прими правила игры

Когда ты добавляешь фреймворк в `composer.json`, ты подписываешь негласный договор. Ты не просто берёшь инструмент — ты принимаешь архитектурный стиль, соглашения, ритм разработки. Ты говоришь: *«Эта платформа решает мои задачи. Я готов работать по её правилам»*.

Но что часто делают разработчики после этого? Начинаем сопротивляться. Гнём платформу под себя. Строим абстракции поверх уже готовых механизмов. Добавляем лишние слои. Изобретаем велосипед, чтобы чувствовать контроль.

Вот конкретный случай. В Laravel у нас есть Eloquent ORM. У модели `User` есть уже готовый интерфейс к данным: `User::query()`, `User::find()`, `User::where(...)`. Эти методы уже **инкапсулируют доступ к данным**.

Но некоторым разработчикам кажется, что этого недостаточно. Они строят поверх этого `UserRepositoryInterface`, `EloquentUserRepository`, `CachedUserRepository`, внедряют их в сервисы, пишут фабрики. Почему?

Потому что где-то они прочитали, что "работа с базой данных должна быть скрыта за интерфейсом". Но этот принцип вырван из контекста. Он применим в условиях, где инфраструктура сложна и разнообразна: файловые БД, распределенные хранилища, переключаемые бэкенды. В Laravel, как в большинстве фреймворков, сам фреймворк уже является адаптером.

В результате мы не получаем ни гибкости, ни производительности. Только архитектурный шум.

Принять фреймворк — значит использовать его силу, выразительность и экосистему. Это не поражение. Это зрелость. Играй по правилам — и ты удивишься, насколько всё может быть просто.

### Мне не нравиться.

Важно понимать, что не все разработчики могут быть открыты к использованию новым для себя инструментов, и насильственное внедрение определенного фреймворка или подхода может привести к сопротивлению или даже саботажу. 

Если вы столкнулись с сопротивлением со стороны вашей команды, необходимо провести открытый и честный разговор, чтобы по возможности уладить их опасения. Поиск совета у опытного профессионала может быть полезным для нахождения взаимоприемлемого решения.

Но если ты чувствуешь, что инструмент тебе не близок, — это нормально. Не пытайся "переделать" его под себя. Не стоит быть как наивная девушка, надеющаяся, что парень изменится — и всё станет как в сказке. Так не работает. Это не значит, что ты плохой разработчик. И не значит, что инструмент плохой. Просто вы не совпали.

Слишком часто мы боимся это признать — и начинаем "улучшать". Переписывать, извращать, подгонять. Вместо этого — просто не используй его вовсе. Выбирай те инструменты, которые соответствуют твоей философии и задачам. Не строй CQRS там, где у тебя обычный CRUD. Не впихивай микросервисы в монолит. Не применяй DDD, если у тебя нет сложной предметной области.

Ты либо принимаешь инструмент целиком и используешь его силу.
Либо честно отказываешься — и идёшь другим путём.
Половинчатое принятие — не компромисс, а архитектурное лицемерие.
Борьба с инструментом — всегда путь в хаос.
