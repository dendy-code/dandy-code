# Тесты

Мне не нравится, как испортили слово **тестирование**.

Тестирование испортили. Изуродовали. Потому что часто под этим подразумевают ручную проверку, что продукт работает как задумано после изменений. Это не то, что нужно разработчику, нам нужен контроль качества.

Многие до сих пор думают, что тестированием занимается кто-то другой: тестировщик, QA-инженер, автоматизатор или великий господин начальник. Это не так.

Ты — разработчик — и есть первый тестировщик, ты запускаешь приложение, проверяешь, что оно работает, вносишь изменения и проверяешь, что всё по-прежнему работает.


### Больше юнит-тестов, меньше всего остального

В мире тестирования есть много терминов: интеграционные, e2e, smoke, UI, acceptance, snapshot, regression… Становится страшно даже начинать.

Почему? Потому что они:
- Проверяют маленькие части кода (функции, методы, классы).
- Работают быстро.
- Легко читаются и поддерживаются.
- Заставляют твой код быть тестируемым, а значит — аккуратным и логичным.


О чем я говорю? Как это связано с разработкой?

Допустим у нас есть endpoint который должен вернуть фазу Луны на определенную дату. Мы можем написать feaure-тест, который проверит, что функция, вычисляющая фазу Луны, работает правильно. В нем мы обратимся по адресу `/api/moon?date=2025-06-01`, получим ответ и проверим, что он соответствует ожидаемому значению.

```php
// Плохо ❌
public function test_returns_moon_phase_data(): void
{
    $response = $this->getJson('/api/moon?date=2025-06-01')
                     ->assertOk()
                     ->assertJsonStructure(['age', 'phase', 'distance', 'nextNewMoon'])
                     ->json();

    $this->assertEquals(13.8, round($response['age'], 1));
    $this->assertEqualsWithDelta(0.47, $response['phase'], 0.01);
    $this->assertEqualsWithDelta(384400, $response['distance'], 50000);
    $this->assertGreaterThan(strtotime('2025-06-01'), $response['nextNewMoon']);
}
```

Но как именно работает функция, вычисляющая фазу Луны? Как она получает данные о Луне? Как она обрабатывает дату? И вроде бы всё хорошо, но это обманка. Такой тест ничего не говорит о логике внутри. Он — витрина. Он проверяет фасад, но не фундамент. Он проверяет только конечный результат. 

Мы можем написать в код прямо контроллере и добавить туда с десяток функций, которые будут вызывать другие функции, и в итоге получим правильный ответ. Но это фигня.

Вместо этого как можно больше должно быть unit тестов — тестов, которые проверяют отдельные части кода. 
А что бы проверять отдельные части кода, вам придется использовать объекты:

```php
// Хорошо ✅
public function test_moon_phase_for_known_date(): void
{
    $date = new DateTimeImmutable('2025-06-01');
    $moon = new MoonPhase($date);

    // Проверяем округлённые значения
    $this->assertEquals(13.8, round($moon->age, 1));
    $this->assertEqualsWithDelta(0.47, $moon->phase, 0.01); // ≈ 47% цикла
    $this->assertEqualsWithDelta(384400, $moon->distance, 50000); // ±50k км — синусоида
    $this->assertGreaterThan($date->getTimestamp(), $moon->nextNewMoon);
}
```

Теперь ни у кого не получиться добавить новый метод в контроллер или не предназначеное для этого уровня.

### Arrange–Act–Assert (AAA)
Разделяйте тест на три логических фазы:

- Arrange. Подготовьте данные, объекты и окружение.
- Act. Выполните единственное действие — метод, который тестируете.
- Assert. Убедитесь, что результат совпадает с ожиданием (одно утверждение = одно тестовое поведение).

```php
public function test_something(): void
{
    // Arrange: подготовка данных
    $obj = new MyClass(...);

    // Act: выполнение действия
    $result = $obj->doWork();

    // Assert: проверка результата
    $this->assertTrue($result->isSuccessful());
}
```


Если с выолнением действия и проверкой результата всё понятно, то с подготовкой данных могут быть нюансы.
Подготовка данных это главная часть теста, и она должна быть максимально простой и понятной.

Например, если вы тестируете метод, который работает с базой данных, то вам нужно создать необходимые записи в базе. Но не нужно создавать всю базу целиком, достаточно только тех записей, которые нужны для теста.


Есть несколько способов как организовать подготовку данных. Например определить заранее записи в базе данных которые бы записывались перед исполнением теста.
```yaml
users:
  - id: 1
    name: Иван Иванов
    email: ivan.ivanov@example.com
    password: '$2y$10$e0NRDUE8...hashedpassword...'  # "password123"
    created_at: 2024-05-01 10:00:00
    updated_at: 2024-05-01 10:00:00

  - id: 2
    name: Мария Петрова
    email: maria.petrova@example.com
    password: '$2y$10$Fjs98JDk...hashedpassword...'  # "secret456"
    created_at: 2024-05-02 12:30:00
    updated_at: 2024-05-02 12:30:00
```

Это заставляет нас каждый раз возвращается к этому файлу и обновлять его, когда мы добавляем новые поля в модель. При написании теста нам нужно сначала создать эти записи, а потом уже использовать их в тестах.
Мы не знаем, а точно ли используется пользователь #2 в проекте или мы просто забыли удалить его из этого файла.

Тогда в тесте будет выглядеть примерно так:

```php
// Плохо ❌
public function test_something(): void
{
    $user = User::find(2);
}
```

Кроме того, мы не видим ни каких подробностей пользователя который мы используем в тесте. Мы не знаем, что это за пользователь, какие у него данные и зачем он нужен.

Лучше всего, что бы подготовка была максимально близка к тестируемому коду. Например, если мы тестируем метод, который работает с пользователем, то лучше всего создать пользователя прямо в тесте:

```php
// Хорошо ✅
public function test_something(): void
{
    $user = User::factory()
        ->withPassword('password123')
        ->create();
}
```


### Рекомендации по организации тестов

Тесты должны зеркалировать структуру вашего приложения. Это поможет вам быстро находить нужные тесты и понимать, что они проверяют.

```php
tests/
├─ Unit/
│   └─ MoonPhaseTest.php
└─ Feature/
    └─ MoonPhaseTest.php
```

### Независимость тестов

Работая с тестами, иногда можно столкнуться с неприятной ситуацией: один тест проходит, только если выполняется сразу
после другого. И если изменить порядок, этот тест ломается.

Это говорит о том, что тесты зависят друг от друга. А идеальный тест всегда должен быть независимым и начинаться с
«чистого листа».

Хороший способ обнаружить такие скрытые зависимости это запускать тесты в случайном порядке. Если тест не проходит,
когда порядок перемешан, это значит, что он зависит от других, и с этим нужно что-то сделать.

PHPUnit и Laravel поддерживают специальный флаг для случайного порядка `--order-by=random`

```bash
# Для Laravel
php artisan test --order-by=random

# Для Laravel Dusk
php artisan dusk --order-by=random

# Для PHPUnit
vendor/bin/phpunit --order-by=random
```

Попробуйте запустить свои тесты в случайном порядке и посмотрите, есть ли у вас зависимые тесты. 😉

Еще лучше добавьте атрибут `executionOrder` в конфигурационный файл, что бы запуск тестов в случайном порядке был по
умолчанию 🚀.

```html
<?xml version="1.0" encoding="UTF-8"?>
<phpunit
        executionOrder="random"
>
```
