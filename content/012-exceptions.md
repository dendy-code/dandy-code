# Обработка ошибок

Каждый раз, когда вы пишете код, вы должны помнить о том, что он может сломаться. 
Ошибки могут возникать по самым разным причинам: от неправильного ввода данных до сбоев в работе внешних сервисов. Поэтому важно правильно обрабатывать ошибки, чтобы ваш код не падал и не оставлял пользователей в недоумении.

### Исключения

Все исключения которые вы создали, но не обработали должны наследоваться от `\RuntimeException`. 

Тезисы: 
- Все что не обработано должно быть `RuntimeException`
- Скрытое проглатывание ошибок
- Ясные ошибки Не "NullPointerException", а "Невозможно подключиться к Redis: соединение таймаутилось".


Не проглатывайте исключения. 
Абсолютно ни в коем случае нельзя «поймать и забыть» исключение. 
Пустой catch или молчаливое подавление ошибок:

```php
// Плохо ❌
try {
    $this->calculate($data);
} catch (\Throwable $throwable) {
    // ничего не делаем
}
```
– «смертельно» опасен: проблема произошла, но никто об этом не узнает. Главное — не потерять факт ошибки.
Так делать нельзя: ошибка уходит в тень, вы теряете информацию.


В некоторых случаях вместо падения можно вернуть резервный результат:
```php
// Плохо ❌
try {
    $message = $this->greeting($time);
} catch (ExternalApiException $exception) {
    $message = 'Добро пожаловать!';
}
```

Это достаточно редко, но иногда может имеет смысл, но обязательно нужно логировать ошибку:
```php
// Хорошо ✅
try {
    $message = $this->greeting($time);
} catch (ExternalApiException $exception) {
    Log::warning('Не удалось получить приветствие', [
        'arguments' => ['time' => $time],
        'exception' => $exception
    ]);

    $message = 'Добро пожаловать!';
}
```


### Обязательно мониторинг логов

Каждое необработанное исключение должно быть зафиксировано в логах. 

Собираем все ошибки в одном месте! Ведем статистику и учет.

- Структурированные логи!
- Ротация логов: включи logrotate, чтобы диск не забился.
- 


### Отладка

Среди разработчиков укоренилось мнение, что пошаговая отладка, например с помощью Xdebug, признак хорошего разработчика. Выглядит это следующим образом: разработчик ставит точку остановки, затем начинает "шагать" по коду, наблюдает за значениями переменных, отслеживает условные переходы — словно читает чужие мысли.

Но позвольте — если вам нужно так делать, значит, что-то пошло не так!

Это не норма. Значит, ваш код неочевиден, сложен и плохо структурирован.

Настоящая причина, по которой вам нужен Xdebug, в том, что вы не понимаете, что происходит в системе.
И не потому что вы недостаточно умны — а потому что код запутан. В нём всё связано со всем, всё влияет на всё, и даже чтобы просто проверить расчёт скидки, вам приходится запускать сервер, кликать через интерфейс и ставить точку останова где-то внутри `processOrder()`.

Вот как это обычно выглядит:

```php
// Плохо ❌
function handleRequest($input) {
    try {
        $value = complexCalculation($input);
        if ($value > 0) {
            $details = $this->service->getDetails($value);
            if ($details && $details['status'] == 'ok') {
                processDetails($details);
                return;
            }
        }
        for ($i = 0; $i < 5; $i++) {
            try {
                retryOperation($i);
                break;
            } catch (Exception $exception) {
                // пустое
            }
        }
    } catch (Exception $exception) {
        Log::error($e);
    }
}
```

Здесь есть и вложенные блоки `try-catch`, и `if` внутри `if`, и цикл с ловлей исключений «внутри» функции. Без отладки трудно понять: за какой именно шаг «цепи» падает — внешняя обработка или внутренняя. Такой код трудно тестировать: чтобы проверить `handleRequest`, нужно настроить и дублировать логику `complexCalculation`, `service->getDetails` и т.д.


А теперь посмотрите, как это должно быть устроено:

```php

```

Всё. Логика выделена, изолирована, читается за секунду.

Вы можете протестировать её без всякого дебаггера:

```php

```

